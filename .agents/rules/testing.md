# Rule: Testing

Frontend testing patterns using Vitest and React Testing Library.

## Testing Philosophy

Write tests that:
1. Give confidence code works as expected
2. Are maintainable and easy to understand
3. Test behavior, not implementation details
4. Focus on user-facing functionality

### What to Test

- ✅ User interactions (clicks, inputs, form submissions)
- ✅ Rendered output based on props/state
- ✅ Conditional rendering logic
- ✅ Utility functions and custom hooks
- ✅ Error states and edge cases
- ✅ Accessibility (ARIA attributes, keyboard navigation)

### What NOT to Test

- ❌ Implementation details (internal state, private methods)
- ❌ Third-party library functionality
- ❌ CSS styling (unless critical to functionality)
- ❌ Generated code (`route-tree.gen.ts`, `styled-system`)
- ❌ Type definitions alone

## Testing Tools

### Stack

- **Vitest**: Test runner (Jest-compatible API)
- **jsdom**: Browser environment simulation
- **React Testing Library**: Component testing utilities
- **@testing-library/user-event**: User interaction simulation
- **@testing-library/jest-dom**: Additional matchers
- **@vitest/coverage-v8**: Code coverage reporting

### Configuration

Tests configured in:
- `vitest.config.ts`: Vitest settings
- `src/setup-tests.ts`: Global test setup

## Test Structure

### File Organization

```
src/
├── component/
│   ├── component.tsx
│   ├── component.test.tsx       # Component tests
│   └── __snapshots__/
│       └── component.test.tsx.snap  # Auto-generated by Vitest
```

### Naming Conventions

- **Test files**: `component-name.test.tsx`
- **Test suites**: `describe('ComponentName', () => {})`
- **Test cases**: `it('does something', () => {})` or `test('does something')`

### Arrange-Act-Assert Pattern

```typescript
it('displays user name when provided', () => {
  // Arrange: Setup test data and render component
  const userName = 'John Doe';
  render(<UserProfile name={userName} />);
  
  // Act: Perform action (if needed)
  // (No action needed for this test)
  
  // Assert: Verify expected behavior
  expect(screen.getByText(userName)).toBeInTheDocument();
});
```

## Component Testing

### Standard Pattern: render() + screen

**Always use this pattern:**
```typescript
import { render, screen } from '@testing-library/react';
import { Button } from './button';

describe('Button', () => {
  it('renders with label', () => {
    render(<Button label="Click me" onClick={() => {}} />);
    
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });
});
```

**Key points:**
- Call `render()` without destructuring (unless you need `container` for snapshots)
- Use `screen` to query elements
- Use `const { container } = render()` only for snapshot tests

### Testing Props

```typescript
it('applies variant styles', () => {
  const { rerender } = render(<Button variant="primary" />);
  expect(screen.getByRole('button')).toHaveClass('primary');
  
  rerender(<Button variant="secondary" />);
  expect(screen.getByRole('button')).toHaveClass('secondary');
});
```

### Testing State Changes

```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

it('toggles visibility on click', async () => {
  const user = userEvent.setup();
  render(<ToggleComponent />);
  
  expect(screen.queryByText('Hidden content')).not.toBeInTheDocument();
  
  await user.click(screen.getByRole('button'));
  
  expect(screen.getByText('Hidden content')).toBeInTheDocument();
});
```

### Testing Conditional Rendering

```typescript
it('shows loading state', () => {
  render(<UserProfile isLoading={true} />);
  expect(screen.getByText('Loading...')).toBeInTheDocument();
});

it('shows error state', () => {
  render(<UserProfile error="Failed to load" />);
  expect(screen.getByText('Failed to load')).toBeInTheDocument();
});

it('shows user data when loaded', () => {
  const user = { name: 'John', email: 'john@example.com' };
  render(<UserProfile user={user} />);
  
  expect(screen.getByText('John')).toBeInTheDocument();
  expect(screen.getByText('john@example.com')).toBeInTheDocument();
});
```

### Testing User Events

```typescript
import userEvent from '@testing-library/user-event';

describe('Form', () => {
  it('handles text input', async () => {
    const user = userEvent.setup();
    render(<Form />);
    
    const input = screen.getByLabelText('Name');
    await user.type(input, 'John Doe');
    
    expect(input).toHaveValue('John Doe');
  });
  
  it('submits form', async () => {
    const user = userEvent.setup();
    const handleSubmit = vi.fn();
    render(<Form onSubmit={handleSubmit} />);
    
    await user.type(screen.getByLabelText('Name'), 'John');
    await user.click(screen.getByRole('button', { name: 'Submit' }));
    
    expect(handleSubmit).toHaveBeenCalledWith({ name: 'John' });
  });
});
```

## Snapshot Testing

### When to Use Snapshots

- Stable component structures
- Complex rendered output that's unlikely to change
- Preventing unintended UI changes
- Component prop variations

### Creating Snapshots

```typescript
import { render } from '@testing-library/react';

describe('Component', () => {
  it('matches snapshot', () => {
    const { container } = render(<Component />);
    expect(container).toMatchSnapshot();
  });
  
  it('matches snapshot with props', () => {
    const { container } = render(<Component variant="primary" />);
    expect(container).toMatchSnapshot();
  });
});
```

**Note:** Destructure `{ container }` from `render()` for snapshot tests only.

### Updating Snapshots

When intentional changes occur:

```bash
pnpm test:run -- -u    # Update all snapshots
```

**⚠️ Important:**
- Review snapshot diffs carefully before updating
- Snapshots are stored in `__snapshots__/` (auto-generated)
- **Never manually edit `.snap` files**
- Commit updated snapshots with code changes
- Snapshots should be part of code review

## Hook Testing

### Testing via Component

```typescript
import { render, screen } from '@testing-library/react';

const TestComponent = () => {
  const iconClass = useIconClass('react');
  return <div data-testid="icon-class">{iconClass}</div>;
};

it('returns correct icon class', () => {
  render(<TestComponent />);
  expect(screen.getByTestId('icon-class')).toHaveTextContent('devicon-react');
});
```

### Testing Hook Directly

```typescript
import { renderHook } from '@testing-library/react';

describe('useIconClass', () => {
  it('returns correct icon class', () => {
    const { result } = renderHook(() => useIconClass('react'));
    expect(result.current).toBe('devicon-react');
  });
  
  it('updates when parameter changes', () => {
    const { result, rerender } = renderHook(
      ({ type }) => useIconClass(type),
      { initialProps: { type: 'react' } }
    );
    
    expect(result.current).toBe('devicon-react');
    
    rerender({ type: 'typescript' });
    expect(result.current).toBe('devicon-typescript');
  });
});
```

## Testing Best Practices

### Query Priority

React Testing Library recommends this priority:

1. **`getByRole`**: `screen.getByRole('button', { name: 'Submit' })`
2. **`getByLabelText`**: `screen.getByLabelText('Email')`
3. **`getByPlaceholderText`**: `screen.getByPlaceholderText('Enter email')`
4. **`getByText`**: `screen.getByText('Welcome')`
5. **`getByDisplayValue`**: `screen.getByDisplayValue('Current value')`
6. **`getByAltText`**: `screen.getByAltText('Profile picture')`
7. **`getByTitle`**: `screen.getByTitle('Tooltip text')`
8. **`getByTestId`**: `screen.getByTestId('custom-element')` (last resort)

**Prefer accessible queries** (`getByRole`, `getByLabelText`) as they encourage accessible markup.

### Query Variants

- **`getBy*`**: Throws error if not found (for elements that should exist)
- **`queryBy*`**: Returns null if not found (for elements that might not exist)
- **`findBy*`**: Async, waits for element (for elements that appear asynchronously)

```typescript
// Element should exist
expect(screen.getByText('Hello')).toBeInTheDocument();

// Element might not exist
expect(screen.queryByText('Optional')).not.toBeInTheDocument();

// Element appears after async operation
expect(await screen.findByText('Loaded')).toBeInTheDocument();
```

### Async Testing

For async operations:

```typescript
it('loads and displays data', async () => {
  render(<AsyncComponent />);
  
  // Initially shows loading
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  // Wait for data to load
  expect(await screen.findByText('Loaded data')).toBeInTheDocument();
  
  // Loading indicator should be gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});
```

**Async utilities:**
- **`findBy*`**: Wait for element to appear (default timeout: 1000ms)
- **`waitFor`**: Wait for assertion to pass
- **`waitForElementToBeRemoved`**: Wait for element to disappear

```typescript
import { waitFor, waitForElementToBeRemoved } from '@testing-library/react';

// Wait for any assertion
await waitFor(() => {
  expect(mockFn).toHaveBeenCalled();
});

// Wait for element to be removed
await waitForElementToBeRemoved(() => screen.queryByText('Loading...'));
```

### Mocking

#### Mock Functions

```typescript
const handleClick = vi.fn();

it('calls handler on click', async () => {
  const user = userEvent.setup();
  render(<Button onClick={handleClick} />);
  
  await user.click(screen.getByRole('button'));
  
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

#### Mock Return Values

```typescript
const mockFetch = vi.fn();
mockFetch.mockResolvedValue({ data: 'test' });
mockFetch.mockRejectedValue(new Error('Failed'));
```

#### Mock Modules

Use utilities in `src/test-utils/` for common mocks:
- `mock-metadata.ts`: Mock metadata hook
- `setups/use-metadata.ts`: Setup metadata mocking

```typescript
import { mockMetadata } from '../test-utils/mock-metadata';

beforeEach(() => {
  mockMetadata({ title: 'Test Page' });
});
```

### Cleanup

Vitest and React Testing Library handle cleanup automatically.

**Manual cleanup** (rarely needed):
```typescript
afterEach(() => {
  vi.clearAllMocks();
});
```

## Code Coverage

### Coverage Expectations

- **Qualitative goal**: High coverage on core modules
- **Focus areas**: `src/resume/**` and `src/icons/**`
- Don't obsess over 100% coverage
- Prioritize meaningful tests over coverage percentage

### Running Coverage

```bash
pnpm test:run --coverage
```

Coverage reports show:
- Line coverage
- Branch coverage
- Function coverage
- Uncovered lines

### Coverage Reports

- **Console output**: Summary in terminal
- **HTML report**: `coverage/index.html` (if configured)
- View detailed coverage by file

### What to Cover

- ✅ Business logic and utility functions
- ✅ Component rendering with various props
- ✅ User interaction flows
- ✅ Error handling paths
- ✅ Edge cases and boundary conditions

### What to Skip

- ❌ Trivial getters/setters
- ❌ Type definitions
- ❌ Configuration files
- ❌ Generated code (`route-tree.gen.ts`, `styled-system`)
- ❌ Test utilities themselves

## Common Testing Patterns

### Setup with beforeEach

```typescript
describe('Component', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  
  it('test 1', () => { /* ... */ });
  it('test 2', () => { /* ... */ });
});
```

### Grouping Related Tests

```typescript
describe('Button', () => {
  describe('variants', () => {
    it('renders primary variant', () => { /* ... */ });
    it('renders secondary variant', () => { /* ... */ });
  });
  
  describe('disabled state', () => {
    it('disables interaction', () => { /* ... */ });
    it('applies disabled styles', () => { /* ... */ });
  });
  
  describe('accessibility', () => {
    it('has correct ARIA attributes', () => { /* ... */ });
  });
});
```

### Testing Multiple Scenarios

```typescript
describe('formatDate', () => {
  it.each([
    [new Date('2025-01-01'), 'January 1, 2025'],
    [new Date('2025-12-31'), 'December 31, 2025'],
  ])('formats %s as %s', (input, expected) => {
    expect(formatDate(input)).toBe(expected);
  });
});
```

### Testing Error Boundaries

Use error boundary testing patterns from React Testing Library documentation.

```typescript
it('renders error boundary fallback', () => {
  const ThrowError = () => {
    throw new Error('Test error');
  };
  
  render(
    <ErrorBoundary>
      <ThrowError />
    </ErrorBoundary>
  );
  
  expect(screen.getByText('Something went wrong')).toBeInTheDocument();
});
```

## Running Tests

### Development

```bash
pnpm test              # Watch mode, interactive
pnpm test:watch        # Explicit watch mode
```

Watch mode automatically re-runs tests when files change.

### CI/Production

```bash
pnpm test:run          # Single run, exit with code
```

Use in CI pipelines for automated testing.

### Filtering Tests

```bash
pnpm test component-name     # Run specific test file
pnpm test -t "test name"     # Run tests matching name
pnpm test src/resume/        # Run tests in directory
```

### Debugging Tests

#### Console Logging

```typescript
it('debugging test', () => {
  render(<Component />);
  
  // Print current DOM
  screen.debug();
  
  // Print specific element
  screen.debug(screen.getByRole('button'));
  
  // Regular console.log
  console.log('Debug info:', someValue);
});
```

#### Testing Playground

```typescript
it('find queries', () => {
  render(<Component />);
  
  // Logs URL to Testing Playground
  screen.logTestingPlaygroundURL();
  
  // Open URL to get query suggestions
});
```

#### VS Code Debugging

Set breakpoints in test files and use VS Code's debugger with Vitest.

## Testing Utilities

### Render Wrapper

Located in `src/test-utils/render-wrapper.tsx`:
- Wraps components with necessary providers
- Includes TanStack Router context
- Includes metadata context
- Use when components need router or metadata context

```typescript
import { render, screen } from '@testing-library/react';
import RenderWrapper from '../test-utils/render-wrapper';

// For components needing router/metadata context
render(<Component />, { wrapper: RenderWrapper });

// Query with screen
expect(screen.getByText('Hello')).toBeInTheDocument();
```

**Standard pattern:**
- Import `render` and `screen` from `@testing-library/react`
- Call `render()` without destructuring
- Use `screen` for all queries
- Only destructure `{ container }` for snapshot tests

### Mock Data

Create mock data in test files or shared fixtures:

```typescript
const mockUser = {
  id: '1',
  name: 'John Doe',
  email: 'john@example.com',
};

const mockUsers = [mockUser, /* ... */];
```

## Accessibility Testing

### Basic A11y Checks

```typescript
it('has accessible button', () => {
  render(<Button>Click me</Button>);
  
  const button = screen.getByRole('button', { name: 'Click me' });
  expect(button).toBeInTheDocument();
});

it('has accessible form input', () => {
  render(
    <label htmlFor="email">
      Email
      <input id="email" type="email" />
    </label>
  );
  
  expect(screen.getByLabelText('Email')).toBeInTheDocument();
});
```

### ARIA Attributes

```typescript
it('has correct ARIA attributes', () => {
  render(<Dialog isOpen={true} />);
  
  expect(screen.getByRole('dialog')).toHaveAttribute('aria-modal', 'true');
});
```

## Best Practices Summary

1. **Test behavior, not implementation**
2. **Use accessible queries** (`getByRole`, `getByLabelText`)
3. **Keep tests simple and focused**
4. **Don't test third-party libraries**
5. **Mock external dependencies**
6. **Use descriptive test names**
7. **Group related tests**
8. **Prefer integration tests over unit tests for components**
9. **Test error states and edge cases**
10. **Keep tests maintainable** (DRY, but not too DRY)
